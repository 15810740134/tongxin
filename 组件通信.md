# 组件通信
### 组件
---
页面组件：我们使用 Vue 时，每个路由代表的页面，都可以称之为组件。
---
基础组件：基本上不掺杂业务逻辑，在项目中可能被大量使用，易于移植。类似的基础组件还有 Button、Input 等，常见于各类 UI 组件库。
---
业务组件：业务组件和项目具体的业务逻辑有大量耦合，一般抽离于当前项目。
---
组件化是为了代码解耦，易于项目的管理与开发

---
## 组件通信方式
---
#### props
Vue 中，最基本的通信方式就是 Props，它是父子组件通信中父组件传值给子组件的一种方式。它允许以数组形式接收，但是更推荐你开启类型检查的形式

所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。

通过子组件改变父组件则通过事件emit

注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。

我们也可以利用这一点，进行组件的通信，但是前提是要时刻让所有人明白这里做了什么。
应用于父组件依赖子组件进行同一数据更改的情况。

### attrs&&listeners

$attrs包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind="$attrs" 传入内部组件——在创建高级别的组件时非常有用。

$listeners 同 $attrs 类似，可以看做是一个包含了组件上所有事件监听器（包括自定义事件、不包括.native修饰的事件）的对象。它也支持上述的写法，适用于将事件安放于组件内指定元素上。

应用于创建基础组件和祖孙组件的通信

### provide&&inject
这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。

provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。

provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。

（绑定根实例？）

多应用于基础组件

### 直接访问组件

ref

简单来说就是获取元素的 Dom 对象和子组件实例。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。在dom加载完成后使用

关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。

$children

当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用 $children 来进行数据绑定，考虑使用一个数组配合 v-for 来生成子组件，并且使用 Array 作为真正的来源。

$parent
访问父实例

以上方法在任何调用方法访问数据时均可用

### bus
$emit的痛点依然是不支持跨级和兄弟组件，Vue 官方推荐我们使用一个新的 Vue 实例来做一个全局的事件通信（或者叫中央事件总线），也就是我们要讲的 EventBus。

额外的创建一个bus实例，利用其事件系统来完成兄弟组件或总线的组件信息交互

当通信不复杂时都可以用这种方法


### vuex

如果数据关系复杂（或者全局性很强）的话就放到VUEX里吧。。。这个没什么说的，按照文档来。。。
